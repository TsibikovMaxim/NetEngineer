<!DOCTYPE html>
<html>
<head>
	<!-- Charset -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SSL</title>
	<!-- Include meta tag to ensure proper rendering and touch zooming-->
	<meta name="view-port" content="width=device-width, initial-scale=1">
	<!-- Include jQuery Mobile stylesheets -->
	<link rel="stylesheet" href="../../../css/jquery.mobile-1.4.5.min.css" />
	<link rel="stylesheet" href="../../../css/themes/my-theme.css" />
	<link rel="stylesheet" href="../../../css/themes/jquery.mobile.icons.min.css" />
	<link rel="stylesheet" href="../../../css/my-style.css" />
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery-1.11.3.min.js"></script>
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery.mobile-1.4.5.min.js"></script>
	<!-- AdMob-->
	<script type="text/javascript" src="../../../js/admob.js"></script>
	<!-- cordova js -->
	<script src="../../../cordova.js"></script>
</head>
<body>

<div data-role="page" id="position" data-theme="a">

	<div data-role="header" data-position="fixed">
		<a data-role="button" data-rel="back" data-ajax="false" class="ui-nodisc-icon transparentButton" data-icon="carat-l" data-iconpos="notext" data-theme="a">Кнопка назад</a>
		<h1>Описание</h1>
		<a href="../../../index.html" data-ajax="false" class="ui-nodisc-icon transparentButton" data-role="button" data-icon="home" data-iconpos="notext" data-shadow="false" data-transition="none" data-theme="a">На главную</a>
	</div>

	<div data-role="main" class="ui-content">

		<h3>SSL</h3>

		<p><strong>SSL</strong> (Secure Sockets Layer — уровень защищённых cокетов) — криптографический протокол, который подразумевает более безопасную связь. Он использует асимметричную криптографию для аутентификации ключей обмена, симметричное шифрование для сохранения конфиденциальности, коды аутентификации сообщений для целостности сообщений. Протокол широко использовался для обмена мгновенными сообщениями и передачи голоса через IP (Voice over IP — VoIP) в таких приложениях, как электронная почта, интернет-факс и др. В 2014 году правительство США сообщило об уязвимости в текущей версии протокола. SSL должен быть исключён из работы в пользу TLS (см. CVE-2014-3566).</p>

		<p>SSL изначально разработан компанией Netscape Communications для добавления протокола HTTPS в свой веб-браузер Netscape Navigator. Впоследствии на основании протокола SSL 3.0 был разработан и принят стандарт RFC, получивший имя TLS.</p>

		<hr><h3>Описание</h3>

		<p>Протокол SSL обеспечивает защищённый обмен данными за счёт двух следующих элементов:</p>

		<ul>
			<li>Аутентификация</li>
			<li>Шифрование</li>
		</ul>

		<p>SSL использует асимметричную криптографию для аутентификации ключей обмена, симметричный шифр для сохранения конфиденциальности, коды аутентификации сообщений для целостности сообщений.</p>

		<p>Протокол SSL предоставляет «безопасный канал», который имеет три основных свойства:</p>

		<ol>
			<li>Канал является частным. Шифрование используется для всех сообщений после простого диалога, который служит для определения секретного ключа.</li>
			<li>Канал аутентифицирован. Серверная сторона диалога всегда аутентифицируется, а клиентская делает это опционально.</li>
			<li>Канал надёжен. Транспортировка сообщений включает в себя проверку целостности.</li>
		</ol>

		<p>Преимуществом SSL является то, что он независим от прикладного протокола. Протоколы приложений (HTTP, FTP, TELNET и т. д.) могут работать поверх протокола SSL совершенно прозрачно, то есть SSL может согласовывать алгоритм шифрования и ключ сессии, а также аутентифицировать сервер до того, как приложение примет или передаст первый байт сообщения.</p>

		<hr><h3>Принцип работы</h3>

		<p>SSL использует среду с несколькими слоями, что обеспечивает безопасность обмена информацией. Конфиденциальность общения присутствует за счет того, что безопасное соединение открыто только целевым пользователям.</p>

		<p><strong>Многослойная среда</strong></p>

		<p>Протокол SSL размещается между двумя протоколами: протоколом, который использует программа-клиент (HTTP, FTP, LDAP, TELNET и т.д.) и транспортным протоколом TCP/IP. SSL защищает данные, выступая в роли фильтра для обеих сторон и передаёт их далее на транспортный уровень.</p>

		<p>Работу протокола можно разделить на два уровня:</p>

		<ol>
			<li>Слой протокола подтверждения подключения (Handshake Protocol Layer)</li>
			<li>Слой протокола записи</li>
		</ol>

		<p>Первый слой, в свою очередь, состоит из трёх подпротоколов:</p>

		<ol>
			<li>Протокол подтверждения подключения (Handshake Protocol)</li>
			<li>Протокол изменения параметров шифра (Cipher Spec Protocol)</li>
			<li>Предупредительный протокол (Alert Protocol)</li>
		</ol>

		<p>Протокол подтверждения подключения используется для согласования данных сессии между клиентом и сервером. К данным сессии относятся:</p>

		<ul>
			<li>Идентификационный номер сессии</li>
			<li>Сертификаты обеих сторон</li>
			<li>Параметры алгоритма шифрования</li>
			<li>Алгоритм сжатия информации</li>
			<li>«Общий секрет» применён для создания ключей; открытый ключ</li>
		</ul>

		<p>Протокол подтверждения подключения производит цепочку обмена данными, что в свою очередь начинает аутентификацию сторон и согласовывает шифрование, хэширование и сжатие. Следующий этап — аутентификация участников, которая осуществляется также протоколом подтверждения подключения.</p>

		<p>Протокол изменения параметров шифра используется для изменения данных ключа (keyingmaterial) — информации, которая используется для создания ключей шифрования. Протокол состоит всего из одного сообщения, в котором сервер говорит, что отправитель хочет изменить набор ключей.</p>

		<p>Предупредительный протокол содержит сообщение, которое показывает сторонам изменение статуса или сообщает о возможной ошибке. Обычно предупреждение отсылается тогда, когда подключение закрыто и получено неправильное сообщение, сообщение невозможно расшифровать или пользователь отменяет операцию.</p>

		<p><strong>Цифровые сертификаты</strong></p>

		<p>Протокол SSL использует сертификаты для проверки принадлежности открытого ключа его реальному владельцу. Способы получения SSL-сертификата:</p>

		<ol>
			<li>Использовать сертификат, выданный CA</li>
			<li>Использовать самоподписанный сертификат</li>
			<li>Использовать «пустой» сертификат</li>
		</ol>

		<p>Самоподписанный сертификат — сертификат, созданный самим пользователем — в этом случае издатель сертификата совпадает с владельцем сертификата. «Пустой» сертификат — сертификат, содержащий фиктивную информацию, используемую в качестве временной для настройки SSL и проверки его функциональности в данной среде.</p>

		<p>Среди сертификатов SSL выделяют сертификаты, подтверждающие домен (Domain-validated certificate) и расширенной проверки. Последний связывает доменное имя с реальным физическим или юридическим лицом.</p>

		<p><strong>Механизмы образования ключа для текущей сессии в SSL/TLS</strong></p>

		<p>Существует 4 основных алгоритма для образования ключей: RSA, Fixed Diffie-Hellman, Ephemeral Diffie-Hellman, Anonymous Diffie-Hellman</p>

		<p><strong>RSA</strong></p>

		<p>При «утере» приватного ключа RSA криптоаналитик, получивший его, получает возможность расшифровать все записанные прошлые сообщения и будущие сообщения. Реализация обмена ключей в RSA является односторонней: вся необходимая информация для образования симметричного ключа, который создается на этапе рукопожатия, пересылается на сервер и шифруется публичным ключом сервера. Раскрытие приватного ключа дает возможность узнать симметричный ключ данной сессии.</p>

		<p><strong>Diffie-Hellman</strong></p>

		<p>Механизм Fixed Diffie-Hellman использует постоянный публичный ключ, который прописан в сертификате сервера. Это также означает, что при каждом новом соединении клиент предоставляет свою часть ключа. После обмена ключами образуется новый симметричный ключ для обмена информацией для текущей сессии. При раскрытии приватного ключа сервера криптоаналитик может расшифровать ранее записанные сообщения, а также все будущие сообщения. Это становится возможным из-за самого механизма. Так как криптоаналитик знает приватный ключ сервера, он сможет узнать симметричный ключ каждой сессии, и даже тот факт, что механизм образования ключа является двусторонним, не поможет.</p>

		<p>Механизм Anonymous Diffie-Hellman не предоставляет гарантий секретности, ибо данные передаются незашифрованными.</p>

		<p>Единственный вариант, при котором гарантируется безопасность прошлых и будущих сообщений — Ephemeral Diffie-Hellman. Разница по сравнению с ранее рассмотренными методами заключается в том, что при каждом новом соединении сервером и клиентом создается одноразовый ключ. Таким образом, даже если криптоаналитику достанется текущий приватный ключ, он сможет расшифровать только текущую сессию, но не предыдущие или будущие сессии.</p>

		<p><strong>Особенности шифрования</strong></p>

		<p>Существует два основных способа шифрования данных: симметричное шифрование (общий секретный ключ) и асимметричное шифрование (пара открытый/приватный ключ).</p>

		<p>SSL использует как асимметричную, так и симметричную криптографию.</p>

		<p>Суть асимметричного шифрования заключается в том, что используется пара ключей. Один из ключей называется открытым (как правило, он публикуется в самом сертификате владельца), а второй ключ называется приватным — он держится в тайне. Оба ключа используются в паре: открытый ключ используется для того, чтобы зашифровать данные, а приватный — для того, чтобы расшифровать их. Такая взаимосвязь позволяет делать две важные вещи.</p>

		<ol>
			<li>Любой пользователь может получить открытый ключ и использовать его для шифрования данных, расшифровать которые сможет только пользователь, владеющий приватным ключом.</li>
			<li>Если владелец ключевой пары "зашифрует" (подпишет) данные своим приватным ключом, то каждый сможет убедиться в том, что данные были отправлены именно владельцем приватного ключа и не были изменены третьей стороной. Именно это является основой цифровых подписей.</li>
		</ol>

		<p>RSA — один из самых распространённых алгоритмов асимметричного шифрования.</p>

		<p>При использовании симметричного шифрования один и тот же ключ используется как для шифрования, так и для расшифровывания данных. Если стороны хотят обменяться зашифрованными сообщениями в безопасном режиме, то у обеих сторон должны быть одинаковые симметричные ключи. Такой тип шифрования используется для большого объёма данных (так как симметричное шифрование является более быстрым). Обычно используются алгоритмы DES, 3-DES, RC2, RC4 и AES.</p>

		<p>Протокол SSL использует шифрование с открытым ключом для взаимной аутентификации клиента и сервера (с помощью технологии цифровых подписей), а также для выработки сессионного ключа, который, в свою очередь, используется более быстрыми алгоритмами симметричной криптографии для шифрования большого объёма данных.</p>

		<p><strong>Хеширование</strong></p>

		<p>Хеш-значение является идентификатором сообщения, его размер меньше размера оригинального сообщения. Самыми известными хеш-алгоритмами являются MD5 (Message Digest 5), который создает 128-битное хеш-значение, SHA-1 (Secure Hash Algorithm), создающий 160-битное хеш-значение, SHA-2 и SHA-3. Результат работы алгоритма хеширования — значение, которое используется для проверки целостности передачи данных.</p>

		<p><strong>Уровень записи</strong></p>

		<p>Протокол на уровне слоя записи получает зашифрованные данные от программы-клиента и передает их на транспортный слой. Протокол записи берет данные, разбивает их на блоки и выполняет шифрование (расшифровывание) данных. При этом активно используется информация, которая была согласована во время подтверждения данных.</p>

		<p>Протокол SSL позволяет использовать шифрование симметричным ключом, используя либо блочные, либо потоковые шифры. Обычно на практике применяются блочные шифры. Принцип работы блочного шифра заключается в отображении блока открытого текста в такой же блок шифрованного текста. Этот шифр можно представить в виде таблицы, содержащей 2128 строк, каждая строка содержит блок открытого текста M и соответствующий ему блок шифрованного текста C. Подобная таблица существует для каждого ключа.</p>

		<p>Шифрование можно обозначить в виде функции</p>

		<p>C = E(Key, M), где M — исходные данные, Key — ключ шифрования, С — зашифрованные данные.</p>

		<p>Как правило, блоки имеют небольшой размер (обычно 16 байт), поэтому возникает вопрос: как зашифровать длинное сообщение?</p>

		<p>Первый режим для подобного шифрования называется ECB (Electronic Codebook) или режим простой замены. Его суть состоит в том, что мы разбиваем исходное сообщение на блоки (по те же 16 байт) и шифруем каждый блок отдельно. Однако данный режим применяет редко из-за проблемы сохранения статистических особенностей исходного текста: 2 одинаковых блока открытого текста после шифрования превратятся в два одинаковых блока зашифрованного текста.</p>

		<p>ля решения этой проблемы был разработан второй режим — CBC (Cipher-block chaining). В этом случае каждый новый блок шифротекста XOR’ится с предыдущим результатом шифрования. Первый блок XOR’ится c некоторым вектором инициализации (Initialization Vector, IV). Однако вся вышеизложенная теория разработана для одного большого объекта, в то время как SSL, являясь криптографическим протоколом, должен шифровать серию пакетов. В такой ситуации существует два способа применения CBC:</p>

		<ol>
			<li>Обрабатывать каждое сообщение как отдельный объект, генерируя для него каждый раз новый вектор инициализации</li>
			<li>Обрабатывать все сообщения как один большой объект, сохраняя режим CBC между ними. В таком случае в качестве вектора инициализации для сообщения n будет использоваться последний блок шифрования предыдущего сообщения (n-1)</li>
		</ol>

		<hr><h3>Применение</h3>

		<p>При проектировании приложений SSL реализуется "под" любым другим протоколом прикладного уровня, таким как HTTP, FTP, SMTP, NNTP и XMPP, таким образом обеспечивая "прозрачность" его использования. Исторически SSL был использован, в первую очередь, с надёжными транспортными протоколами, такими как Transmission Control Protocol (TCP). Тем не менее, он также был реализован с датаграммными транспортными протоколами, такими как User Datagram Protocol (UDP) и Datagram Control Protocol (DCCP), использование которого было стандартизировано, что привело к появлению термина Datagram Transport Layer Security (DTLS).</p>

		<p><strong>Вебсайты</strong></p>

		<p>Частое использование протокола SSL привело к формированию протокола HTTPS (Hypertext Transfer Protocol Secure), поддерживающего шифрование. Данные, которые передаются по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS, тем самым обеспечивая защиту этих данных. Такой способ защиты широко используется в мире Веб для приложений, в которых важна безопасность соединения, например в платёжных системах. В отличие от HTTP, для HTTPS по умолчанию используется TCP-порт 443.</p>

		<center><img src="../../../images/protocol/ssl.png"></center>

		<p><strong>Использование и реализация</strong></p>

		<p>Изначально виртуальные частные сети (VPN) на основе SSL разрабатывались как дополнительная и альтернативная технология удалённого доступа на основе IPsec VPN. Однако, такие факторы, как достаточная надёжность и дешевизна, сделали эту технологию привлекательной для организации VPN. Также SSL получил широкое применение в электронной почте.</p>

		<p>Наиболее распространённая реализация SSL — криптографический пакет с открытым исходным кодом OpenSSL, основанный на SSLeay, написанной Эриком Янгом. Последняя версия OpenSSL поддерживает SSLv3. Пакет предназначен для создания и управления различного рода сертификатами. Также в его состав входит библиотека для поддержки SSL различными программами. Библиотека используется, например, модулем SSL в распространенном HTTP-сервере Apache.</p>

		<hr><h3>Спецификация протокола записей SSL</h3>

		<p>Формат заголовка записей SSL</p>

		<p>Все данные в SSL пересылаются в виде записей (рекордов) — объектов, которые состоят из заголовка и некоторого количества данных. Каждый заголовок рекорда содержит 2 или 3 байта кода длины. Если старший бит в первом байте кода длины рекорда равен 1, тогда рекорд не имеет заполнителя и полная длина заголовка равна 2 байтам, в противном случае рекорд содержит заполнитель, и полная длина заголовка равна 3 байтам. В случае длинного (3 байта) заголовка второй по старшинству бит первого байта имеет специальное значение. Если он равен 0 — рекорд является информационным, если он равен 1 — рекорд является security escape. Код длины рекорда не включает в себя число байт заголовка. Для 2-байтового заголовка его длина вычисляется так:</p>

		<center><img src="../../../images/protocol/ssl2.png"></center>

		<p>Здесь byte[0] — первый полученный байт, а byte[1] — второй полученный байт.</p>

		<p>Для 3-байтового заголовка длина рекорда вычисляется следующим образом:</p>

		<center><img src="../../../images/protocol/ssl3.png"></center>

		<p>Значение PADDING специфицирует число байтов, добавленных отправителем к исходному рекорду. Данные заполнителя используются для того, чтобы сделать длину рекорда кратной размеру блока шифра. Отправитель добавляет PADDING после имеющихся данных, а затем шифрует всё это, так как длина этого массива кратна размеру блока используемого шифра. Поскольку известен объём передаваемых данных, заголовок сообщения может быть сформирован с учетом объёма PADDING. Получатель сообщения дешифрует всё поле данных и получает исходную информацию, затем вычисляет истинное значение RECORD-LENGTH, при этом PADDING из поля «данные» удаляется.</p>

		<p><strong>Формат информационных записей SSL</strong></p>

		<p>Часть данных рекорда SSL состоит из 3 компонентов:</p>

		<ol>
			<li>MAC-DATA[MAC-SIZE]</li>
			<li>ACTUAL-DATA[N]</li>
			<li>PADDING-DATA[PADDING]</li>
		</ol>

		<p>MAC-DATA — код аутентификации сообщения</p>

		<p>MAC-SIZE — функция используемого алгоритма вычисления хеш-суммы</p>

		<p>ACTUAL-DATA — реально переданные данные или поле данных сообщения</p>

		<p>PADDING-DATA — данные PADDING (при блочном шифровании)</p>

		<center><img src="../../../images/protocol/ssl4.png"></center>

		<p>Здесь SECRET передается хеш-функции первым, затем следует ACTUAL-DATA и PADDING-DATA, за которыми передается SEQUENCE-NUMBER — порядковый номер.</p>
		<p>Значение SECRET зависит от того, кто именно посылает сообщение. Если это делает клиент, то SECRET равен CLIENT-WRITE-KEY. Если же клиент получает сообщение, SECRET равен CLIENT-READ-KEY.</p>

		<p>Порядковый номер представляет собой 32-битовый код, который передается хеш-функции в виде 4 байт, используя сетевой порядок передачи «от старшего к младшему». Порядковый номер — счетчик для сервера или клиента. Для каждого направления передачи используется пара счетчиков — для отправителя и для получателя; каждый раз, когда отправляется сообщение, счетчик увеличивает своё значение на 1.</p>

		<p>Получатель сообщения использует ожидаемое значение порядкового номера для передачи MAC (тип хеш-функции определяется параметром CIPHER-CHOICE). Вычисленное значение MAC-DATA должно совпадать с переданным значением. Если сравнение не прошло, сообщение считается поврежденным, что приводит к возникновению ошибки, которая вызывает закрытие соединения.</p>

		<p>Окончательная проверка соответствия выполняется, когда используется блочный шифр. Объём данных в сообщении (RECORD-LENGTH) должен быть кратен размеру блока шифра. Если данное условие не выполнено, сообщение считается поврежденным, что приводит к разрыву соединения.</p>

		<p>Для 2-байтового заголовка максимальная длина сообщения равно 32767 байтов, для 3-байтового 16383 байтов. Сообщения протокола диалога SSL должны соответствовать одиночным рекордам протокола SSL, а сообщения прикладного протокола могут занимать несколько рекордов SSL.</p>

		<p><strong>Протокол диалога SSL</strong></p>

		<p>Протокол диалога SSL содержит 2 основные фазы.</p>

		<p>Фаза 1</p>

		<p>Первая фаза используется для установления конфиденциального канала коммуникаций.</p>

		<p>Эта фаза инициализирует соединение, когда оба партнера обмениваются сообщениями «hello». Клиент посылает сообщение CLIENT-HELLO. Сервер получает это сообщение, обрабатывает его и посылает в ответ сообщение SERVER-HELLO.</p>

		<p>В этот момент и сервер и клиент имеют достаточно информации, чтобы знать, нужен ли новый master key. Если ключ не нужен, сервер и клиент переходят в фазу 2.</p>

		<p>Когда возникает необходимость создания нового master key, сообщение сервера SERVER-HELLO уже содержит достаточно данных для того, чтобы клиент мог сгенерировать master key. В эти данные входят подписанный сертификат сервера, список базовых шифров и идентификатор соединения (случайное число, сгенерированное сервером, которое используется на протяжении всей сессии). После генерации клиентом master key он посылает серверу сообщение CLIENT-MASTER-KEY или же сообщение об ошибке, когда клиент и сервер не могут согласовать базовый шифр.</p>

		<p>После определения master key сервер посылает клиенту сообщение SERVER-VERIFY, которое аутентифицирует сервер.</p>

		<p>Фаза 2</p>

		<p>Фаза 2 называется фазой аутентификации. Так как сервер уже аутентифицирован на первой фазе, то на второй фазе осуществляется аутентификация клиента. Сервер отправляет запрос клиенту, и если у клиента есть необходимая информация — он присылает позитивный отклик, если же нет — сообщение об ошибке. Когда один партнер выполнил аутентификацию другого партнера — он посылает сообщение finished. В случае клиента сообщение CLIENT-FINISHED содержит зашифрованную форму идентификатора CONNECTION-ID, которую должен верифицировать сервер. Если верификация была неудачной, сервер посылает сообщение ERROR.</p>

		<p>Когда один из партнеров послал сообщение finished — он должен принимать сообщения до тех пор, пока не получит сообщение finished от другого партнера, и только когда оба партнера послали и получили сообщения finished, протокол диалога SSL закончит свою работу. С этого момента начинает работу прикладной протокол.</p>

		<p>Типовой протокол обмена сообщениями</p>

		<p>Ниже представлено несколько вариантов обмена сообщениями в рамках протокола диалога SSL. Клиент — C , сервер — S. «{smth}key» означает что «smth» зашифровано с помощью ключа.</p>

		<center><img src="../../../images/protocol/ssl5.png"></center>

		<center><img src="../../../images/protocol/ssl6.png"></center>

		<center><img src="../../../images/protocol/ssl7.png"></center>

		<hr><h3>Аутентификация и обмен ключами</h3>

		<p>SSL поддерживает 3 типа аутентификации:</p>

		<ul>
			<li>аутентификация обеих сторон (клиент — сервер),</li>
			<li>аутентификация сервера с неаутентифицированным клиентом,</li>
			<li>полная анонимность.</li>
		</ul>

		<p>Если сервер аутентифицирован, то его сообщение о сертификации должно обеспечить верную сертификационную цепочку, ведущую к приемлемому центру сертификации. Проще говоря, аутентифицированный сервер должен предоставить допустимый сертификат клиенту. Каждая сторона отвечает за проверку того, что сертификат другой стороны ещё не истек и не был отозван. Всякий раз, когда сервер аутентифицируется, канал устойчив (безопасен) к попытке перехвата данных между веб-сервером и браузером, но полностью анонимная сессия по своей сути уязвима к такой атаке. Анонимный сервер не может аутентифицировать клиента. Главная цель процесса обмена ключами — это создание секрета клиента (pre_master_secret), известного только клиенту и серверу. Секрет (pre_master_secret) используется для создания общего секрета (master_secret). Общий секрет необходим для того, чтобы создать сообщение для проверки сертификата, ключей шифрования, секрета MAC (message authentication code) и сообщения «finished». Отсылая сообщение «finished», стороны указывают, что они знают верный секрет (pre_master_secret).</p>

		<p><strong>Анонимный обмен ключами</strong></p>

		<p>Полностью анонимная сессия может быть установлена при использовании алгоритма RSA или Диффи-Хеллмана для создания ключей обмена. В случае использования RSA клиент шифрует секрет (pre_master_secret) с помощью открытого ключа несертифицированного сервера. Открытый ключ клиент узнает из сообщения обмена ключами от сервера. Результат посылается в сообщении обмена ключами от клиента. Поскольку перехватчик не знает закрытого ключа сервера, то ему будет невозможно расшифровать секрет (pre_master_secret). При использовании алгоритма Диффи-Хеллмана открытые параметры сервера содержатся в сообщении обмена ключами от сервера, и клиенту посылают в сообщении обмена ключами. Перехватчик, который не знает приватных значений, не сможет найти секрет (pre_master_secret).</p>

		<p><strong>Аутентификация и обмен ключами при использовании RSA</strong></p>

		<p>В этом случае обмен ключами и аутентификация сервера может быть скомбинирована. Открытый ключ также может содержаться в сертификате сервера или может быть использован временный ключ RSA, который посылается в сообщении обмена ключами от сервера. Когда используется временный ключ RSA, сообщения обмена подписываются server’s RSA или сертификат DSS (???). Сигнатура содержит текущее значение сообщения Client_Hello.random, таким образом, старые сигнатуры и старые временные ключи не могут повторяться. Сервер может использовать временный ключ RSA только однажды для создания сессии. После проверки сертификата сервера клиент шифрует секрет (pre_master_secret) при помощи открытого ключа сервера. После успешного декодирования секрета (pre_master_secret) создается сообщение «finished», тем самым сервер демонстрирует, что он знает приватный ключ, соответствующий сертификату сервера.</p>

		<p>Когда RSA используется для обмена ключами, для аутентификации клиента используется сообщение проверки сертификата клиента. Клиент подписывает значение, вычисленное из master_secret и всех предшествующих сообщений протокола рукопожатия. Эти сообщения рукопожатия содержат сертификат сервера, который ставит в соответствие сигнатуре сервера сообщение Server_Hello.random, которому ставит в соответствие сигнатуру текущему сообщению рукопожатия (???).</p>

		<p><strong>Аутентификация и обмен ключами при использовании Diffie-Hellman</strong></p>

		<p>В этом случае сервер может также поддерживать содержащий конкретные параметры алгоритм Диффи-Хеллмана или может использовать сообщения обмена ключами от сервера для посылки набора временных параметров, подписанных сертификатами DSS или RSA. Временные параметры хэшируются с сообщением hello.random перед подписанием для того, чтобы злоумышленник не смог совершить повтор старых параметров. В любом случае клиент может проверить сертификат или сигнатуру для уверенности, что параметры принадлежат серверу.</p>

		<p>Если клиент имеет сертификат, содержащий параметры алгоритма Diffie-Hellman, то сертификат также содержит информацию, требующуюся для того, чтобы завершить обмен ключами. В этом случае клиент и сервер должны будут сгенерировать одинаковые Diffie-Hellman результаты (pre_master_secret) каждый раз, когда они устанавливают соединение. Для того, чтобы предотвратить хранение секрета (pre_master_secret) в памяти компьютера на время дольше, чем необходимо, секрет должен быть переведен в общий секрет (master_secret) настолько быстро, насколько это возможно. Параметры клиента должны быть совместимы с теми, которые поддерживает сервер для того, чтобы работал обмен ключами.</p>

		<hr><h3>Протокол записи</h3>

		<p>Протокол записи (Record Layer) — это уровневый протокол. На каждом уровне сообщения включают поля для длины, описания и проверки. Протокол записи принимает сообщения, которые нужно передать, фрагментирует данные в управляемые блоки, разумно сжимает данные, применяя MAC (message authentication code), шифрует и передаёт результат. Полученные данные он расшифровывает, проверяет, распаковывает, собирает и доставляет к более верхним уровням клиента.</p>

		<p>Существует четыре протокола записи:</p>

		<ol>
			<li>Протокол рукопожатия (handshake protocol);</li>
			<li>Протокол тревоги (alert protocol);</li>
			<li>Протокол изменения шифра (the change cipher spec protocol);</li>
			<li>Протокол приложения (application data protocol);</li>
		</ol>

		<p>Если SSL реализация получает тип записи, который ей неизвестен, то эта запись просто игнорируется. Любой протокол, созданный для использования совместно с SSL, должен быть хорошо продуман, так как будет иметь дело с атаками на него. Заметим, что из-за типа и длины записи, протокол не защищен шифрованием. Внимание следует уделить тому, чтобы минимизировать трафик.</p>

		<p><strong>Протокол рукопожатия</strong></p>

		<p>SSL клиент и сервер договариваются об установлении связи с помощью процедуры рукопожатия. Во время рукопожатия клиент и сервер договариваются о различных параметрах, которые будут использованы, чтобы обеспечить безопасность соединения:</p>

		<ol>
			<li>Клиент посылает серверу номер версии SSL клиента, поддерживаемые алгоритмы шифрования и сжатия, специфичные данные для сеанса и другую информацию, которая нужна серверу, чтобы общаться с клиентом, используя SSL.</li>
			<li>Сервер посылает клиенту номер версии SSL сервера, алгоритм сжатия и шифрования (выбранные из посланных ранее клиентом), специфичные данные для сеанса и другую информацию, которая нужна серверу, чтобы общаться с клиентом по протоколу SSL. Сервер также посылает свой сертификат, который требует проверки подлинности клиента. После идентификации сервер запрашивает сертификат клиента.</li>
			<li>Клиент использует информацию, переданную сервером для проверки подлинности. Если сервер не может быть проверен, пользователь получает предупреждение о проблеме и о том, что шифрование и аутентификация соединения не может быть установлена. Если сервер успешно прошел проверку, то клиент переходит к следующему шагу.</li>
			<li>Используя все данные, полученные до сих пор от процедуры рукопожатие, клиент (в сотрудничестве с сервером) создает предварительный секрет сессии, в зависимости от используемого шифра от сервера, шифрует его с помощью открытого ключа сервера (полученного из сертификата сервера, отправленного на 2-м шаге), а затем отправляет его на сервер.</li>
			<li>Если сервер запросил аутентификацию клиента (необязательный шаг рукопожатия), клиент также подписывает ещё один кусок данных, который является уникальным для этого рукопожатия и известным как для клиента, так и сервера. В этом случае, клиент отправляет все подписанные данные и собственный сертификат клиента на сервер вместе с предварительно зашифрованным секретом.</li>
			<li>Сервер пытается аутентифицировать клиента. Если клиент не может пройти проверку подлинности, сеанс заканчивается. Если клиент может быть успешно аутентифицирован, сервер использует свой закрытый ключ для расшифровки предварительного секрета, а затем выполняет ряд шагов (которые клиент также выполняет), чтобы создать главный секрет.</li>
			<li>И клиент, и сервер используют секрет для генерации ключей сеансов, которые являются симметричными ключами, использующиеся для шифрования и расшифрования информации, которой обмениваются во время SSL сессии. Происходит проверка целостности (то есть, для обнаружения любых изменений в данных между временем когда он был послан, и временем его получения на SSL-соединении).</li>
			<li>Клиент посылает сообщение серверу, информируя его, что будущие сообщения от клиента будут зашифрованы с помощью ключа сеанса. Затем он отправляет отдельное, зашифрованное сообщение о том, что часть рукопожатие закончена.</li>
			<li>И в заключение, сервер посылает сообщение клиенту, информируя его, что будущие сообщения от сервера будут зашифрованы с помощью ключа сеанса. Затем он отправляет отдельное, зашифрованное сообщение о том, что часть рукопожатие закончена.</li>
		</ol>

		<p>На этом рукопожатие завершается, и начинается защищенное соединение, которое зашифровывается и расшифровывается с помощью ключевых данных. Если любое из перечисленных выше действий не удается, то рукопожатие SSL не удалось, и соединение не создается.</p>

		<p><strong>Протокол изменения параметров шифрования</strong></p>

		<p>Протокол изменения параметров шифрования существует для сигнализации перехода в режим шифрования. Протокол содержит единственное сообщение, которое зашифровано и сжато при текущем установленном соединении. Сообщение состоит только из одного бита со значением 1.</p>

		<center><img src="../../../images/protocol/ssl8.png"></center>

		<p>Сообщение изменения шифра посылается клиентом и сервером для извещения принимающей стороны, что последующие записи будут защищены в соответствии с новым договоренным CipherSpec и ключами. Принятие этого сообщения заставляет получателя отдать приказ уровню записи незамедлительно копировать состояние отложенного чтения в состояние текущего чтения. Сразу после послания этого сообщения, тот кто послал должен отдать приказ уровню записи перевести режим отложенной записи в режим текущей записи. Сообщение изменения шифра посылается во время рукопожатия, после того как параметры защиты были переданы, но перед тем как будет послано сообщение «finished».</p>

		<p><strong>Протокол тревоги</strong></p>

		<p>Один из типов проверки, поддерживаемых в протоколе SSL записи, — это протокол тревоги. Сообщение тревоги передаёт трудности, возникшие в сообщении, и описание тревоги. Сообщение тревоги с критическим уровнем незамедлительно прерывает соединение. В этом случае другие соединения, соответствующие сессии, могут быть продолжены, но идентификатор сессии должен быть признан недействительным. Как и другие сообщения, сообщение тревоги зашифровано и сжато, как только указано текущее состояние соединения.</p>

		<p><strong>Протокол приложения</strong></p>

		<p>Сообщение приложения данных работает на уровне записи. Он фрагментируется, сжимается и шифруется на основе текущего состояния соединения. Сообщения считаются прозрачными для уровня записи.</p>

		<hr><h3>Безопасность</h3>

		<p><strong>SSL 2.0</strong></p>

		<p>Существует ряд атак, которые могут быть предприняты против протокола SSL. Однако SSL устойчив к этим атакам при условии, что пользователь использует только доверенные сервера для обработки информации. SSL 2.0 уязвима в некоторых ситуациях:</p>

		<ol>
			<li>Идентичные криптографические ключи используются для аутентификации и шифрования сообщений;</li>
			<li>SSL 2.0 имеет слабую MAC конструкцию, которая использует MD5 хэш-функцию с секретом префикса, что делает его уязвимым для атак;</li>
			<li>SSL 2.0 не имеет никакой защиты для протокола рукопожатия, то есть атаки типа злоумышленник посередине (man-in-the-middle) могут остаться незамеченными;</li>
			<li>SSL 2.0 использует TCP закрытое соединенние, чтобы указать конец данных. Это означает, что возможна следующая атака: злоумышленник просто подделывает TCP FIN, оставив получателя без сообщения о конце передачи данных (в SSL 3.0 эту ошибку исправили);</li>
			<li>SSL 2.0 предполагает наличие единой службы поддержки и фиксированного домена, что идет вразрез со стандартной функцией виртуального хостинга на веб-серверах.</li>
		</ol>

		<p>SSL 2.0 по умолчанию отключена в браузерах начиная с Internet Explorer 7, Mozilla Firefox 2, Opera 9.5 и Safari.</p>

		<p><strong>SSL 3.0</strong></p>

		<p>14 октября 2014 года была выявлена уязвимость CVE-2014-3566, названная POODLE (Padding Oracle On Downgraded Legacy Encryption). Данная уязвимость позволяет злоумышленнику осуществить атаку Man-in-the-Middle на соединение, зашифрованное с помощью SSL 3.0. Уязвимость POODLE — это уязвимость протокола, а не какой-либо его реализации, соответственно, ей подвержены все соединения зашифрованные SSL v3.</p>

		<p>В SSL 3.0 есть и иные слабые моменты. К примеру, половина мастер-ключа (master key), которая устанавливается, полностью зависит от хэш-функции MD5, которая не является устойчивой к коллизиям и, следовательно, не считается безопасной.</p>

		<p><strong>Виды возможных атак</strong></p>

		<p><strong>Атака по словарю</strong></p>

		<p>Такой тип атак производится, когда атакующий имеет представление о том, какого типа сообщения посылаются.</p>

		<p>Криптоаналитик может сформировать базу данных, где ключами являются зашифрованные строки открытого текста. По созданной базе данных можно определить ключ сессии, соответствующий определенному блоку данных.</p>

		<p>Вообще для SSL такие атаки возможны. Но SSL пытается противостоять этим атакам, используя большие ключи сессии — клиент генерирует ключ, который длиннее, чем допускается экспортными ограничениями, часть которого посылается серверу открытым текстом, а остальная часть объединяется с секретной частью, чтобы получить достаточно длинный ключ (например, 128 бит, как этого требует RC4). Способ блокирования атак открытого текста заключается в том, чтобы сделать объём необходимого текста неприемлемо большим. Каждый бит, добавляемый к длине ключа сессии, увеличивает размер словаря в 2 раза. Использование ключа сессии длиной 128 бит делает размер словаря далеко за пределами современных технических возможностей (решение потребует такого количества атомов, которого нет во всей вселенной). Другой способ, с помощью которого SSL может противостоять данной атаке, заключается в использовании максимально возможных длин ключей (в случае не экспортного варианта). Следствием этого является то, что самым простым и дешевым способом атаки становится лобовая атака ключа, но для 128-битного ключа стоимость его раскрытия можно считать бесконечной.</p>

		<p><strong>Атака отражением</strong></p>

		<p>Злоумышленник записывает коммуникационную сессию между сервером и клиентом. Позднее он пытается установить соединение с сервером, воспроизводя записанные сообщения клиента. Но SSL отбивает эту атаку при помощи особого уникального идентификатора соединения (ИС). Конечно, теоретически третья сторона не в силах предсказать ИС, потому что он основан на наборе случайных событий. Однако, злоумышленник с большими ресурсами может записать большое количество сессий и попытаться подобрать «верную» сессию, основываясь на коде nonce, который послал сервер в сообщение Server_Hello. Но коды nonce SSL имеют, по меньшей мере, длину 128 бит, а значит, злоумышленнику необходимо записать 264 кодов nonce, чтобы получить вероятность угадывания 50 %. Но 264 достаточно большое число, что делает эти атаки бессмысленными.</p>

		<p><strong>Атака протокола рукопожатия</strong></p>

		<p>Злоумышленник может попытаться повлиять на обмен рукопожатиями для того, чтобы стороны выбрали разные алгоритмы шифрования, а не те, что они выбирают обычно. Из-за того, что многие реализации поддерживают экспортированное шифрование, а некоторые даже 0-шифрование или MAC-алгоритм, эти атаки представляют большой интерес.</p>

		<p>Для такой атаки злоумышленнику необходимо быстро подменить одно или более сообщений рукопожатия. Если это происходит, то клиент и сервер вычислят различные значения хэшей сообщения рукопожатия. В результате чего стороны не примут друг от друга сообщения «finished». Без знания секрета злоумышленник не сможет исправить сообщение «finished», поэтому атака может быть обнаружена.</p>

		<p><strong>Взлом SSL-соединений внутри ЦОД</strong></p>

		<p>Наиболее известный инцидент по массовому взлому информации, защищенной протоколами SSL, был произведен агентами ФБР с помощью систем Carnivore и NarusInsight, что привело к судебному процессу от лица правозащитной организации Electronic Frontier Foundation против AT&T, который установил данные комплексы для взлома криптографически защищенной информации.</p>

		<p>Несмотря на высокий общественный резонанс в США данного дела и расследование на уровне конституционного комитета Палаты представителей, технологически взлом протокола SSL агентами ФБР не производился. Carnivore и NarusInsight были установлены в самом ЦОД, где находились сервера, ведущие SSL-соединенения с удаленными клиентами. NarusInsight полностью восстановил зашифрованную информацию путём прослушивания не SSL-соединения, а внутреннего траффика между серверами приложений внутри самого ЦОД, уже после того как данные, поступившие по SSL, были расшифрованы самим сервером, принявшим их от внешних пользователей.</p>

		<p>Тем не менее, указанный инцидент показал, что SSL не может являться надёжным средством криптозащиты данных серверов в Интернете, так как спецслужбы могут установить системы прослушивания, такие как NarusInsight или СОРМ-2, в ЦОД. Любой вид криптографии, подразумевающий, что ключи от шифров находятся у сервера-получателя в ЦОД, взламываются снифферами спецслужб в автоматическом режиме за счет внедрения их в самого получателя. Далее данные полностью реконструируются по процедурам, которые на данный момент регулируются и законодательными актами, такими как «Патриотический акт». Причем указанные законодательные акты запрещают вплоть до судебного преследования владельцев ЦОД удаление снифферов спецслужб из внутренней части серверов-получателей. С учетом наличия данных систем, протокол SSL может защищать только соединение двух пользователей в Интернете, но не SSL-соединение с внешним Web-сайтом.</p>

		<p><strong>BEAST атака</strong></p>

		<p>23 сентября 2011 года тайские исследователи Дуонг и Джулиано Риццо, используя Java апплет, продемонстрировали «доказательство концепции» под названием Beast («Browser Exploit Against SSL/TLS»), указывающей уязвимость в TLS 1.0. Ранее эту уязвимость, которая первоначально была обнаружена Phillip Rogaway в 2002 году, практически никто не мог продемонстрировать. Уязвимость TLS 1.1 была зафиксирована в 2006 году.</p>

		<p>Атака строится на нескольких допущениях, но, как оказалось, их вполне реально реализовать. Во-первых, криптоаналитик должен иметь возможность перехватывать трафик, передаваемый браузером. Во-вторых, необходимо как-то заставить пользователя передавать данные по тому же самому безопасному каналу связи. Пусть между компьютерами Боба (B) и Алисы (А) установлено безопасное соединение. Предположим, что i-ый блок попавшего к нам сообщения содержит секретную информацию (например, пароль).</p>

		<center><img src="../../../images/protocol/ssl9.png"></center>

		<p>Предположим что пароль А — P. Мы можем проверить правильность нашего предположения:</p>

		<p>Итак, мы смогли перехватить вектор инициализации, который используется для шифрования первого блока следующего сообщения, но это же есть последний блок предыдущего сообщения(в зашифрованном виде) — IV. Также мы перехватили C<sub>i-1</sub>.При помощи этих данных мы формируем сообщение так, чтобы первый блок стал равен следующему:</p>

		<center><img src="../../../images/protocol/ssl10.png"></center>

		<p>Если криптоаналитик сможет передать сообщение по тому же защищенному каналу, то первый блок нового сообщения примет вид:</p>

		<center><img src="../../../images/protocol/ssl11.png"></center>

		<p>Получается, если P = M, то первый зашифрованный блок нового сообщения С<sub>1</sub> будет равен ранее перехваченному С<sub>i</sub>.</p>

		<p>На практике возникает проблема: блок М — 16 байтов в длину, даже если мы знаем все байты кроме двух нам потребуется 215 попыток чтобы угадать оставшееся. А если мы не знаем ничего?</p>

		<p>Отсюда вывод что данная практика может сработать в том случае, если криптоаналитик имеет ограниченное количество предположений относительно значения М, а точнее большую часть содержимого данного блока. Следующее допущение: криптоаналитик может контролировать расположение данных в блоке, например знать что пароль — n символов в длину. Зная это, криптоаналитик располагает пароль таким образом чтобы в первый блок попал только 1 символ, а оставшиеся (n-1) в следующий — то есть в первых 15 байтах лежат заведомо известные данные. А для угадывания 1 символа злоумышленнику потребуется в худшем 256 попыток.</p>

		<p>На самом деле, об уязвимости знали гораздо раньше, просто разработчики утилиты — первые, кому удалось реализовать все условия для данной атаки. А именно:</p>

		<ol>
			<li>Криптоаналитик имеет возможность прослушивать сетевые соединения, инициированные браузером атакуемого компьютера</li>
			<li>У криптоаналитика есть возможность внедрить агент в браузер жертвы</li>
			<li>Агент имеет возможность отправлять произвольные HTTPS-запросы</li>
		</ol>

		<hr><h3>Обработка ошибок в протоколе SSL</h3>

		<p>В протоколе SSL обработка ошибок очень проста. Когда ошибка обнаружена, тот, кто её обнаружил, посылает об этом сообщение своему партнёру. Неустранимые ошибки требуют от сервера и клиента разрыва соединения. Протокол SSL определяет следующие ошибки:</p>

		<ol>
			<li>Unsupported_Certificate_Type_Error: такая ошибка возникает, когда клиент/сервер получает тип сертификата, который не поддерживается. Ошибка устранима (только для аутентификации клиента).</li>
			<li>No_Cipher_Error: ошибка возникает, когда сервер не может найти размер ключа или шифр, который поддерживается также и клиентом. Ошибка неустранима.</li>
			<li>Bad_Certificate_Error: такая ошибка возникает, когда сертификат считается принимающей стороной плохим. Это означает, что или некорректна подпись сертификата, или его значение некорректно. Ошибка устранима (только для аутентификации клиента).</li>
			<li>No_Certificate_Error: если послано сообщение Request_Certificate, то эта ошибка может быть прислана по причине того, что клиент не имеет сертификата. Ошибка устранима.</li>
		</ol>

		<hr><h3>Алгоритмы, использующиеся в SSL</h3>

		<ul>
			<li>Для обмена ключами и проверки их подлинности применяются: RSA, Diffie-Hellman, ECDH, SRP, PSK.</li>
			<li>Для аутентификации: RSA, DSA, ECDSA.</li>
			<li>Для симметричного шифрования: RC2, RC4, IDEA, DES, Triple DES или AES, Camellia.</li>
			<li>Для хеш-функций: SHA, MD5, MD4 и MD2.</li>
		</ul>

	</div>

</div>


</body>
</html>