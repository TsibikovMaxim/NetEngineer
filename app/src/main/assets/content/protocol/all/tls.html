<!DOCTYPE html>
<html>
<head>
	<!-- Charset -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>TLS</title>
	<!-- Include meta tag to ensure proper rendering and touch zooming-->
	<meta name="view-port" content="width=device-width, initial-scale=1">
	<!-- Include jQuery Mobile stylesheets -->
	<link rel="stylesheet" href="../../../css/jquery.mobile-1.4.5.min.css" />
	<link rel="stylesheet" href="../../../css/themes/my-theme.css" />
	<link rel="stylesheet" href="../../../css/themes/jquery.mobile.icons.min.css" />
	<link rel="stylesheet" href="../../../css/my-style.css" />
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery-1.11.3.min.js"></script>
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery.mobile-1.4.5.min.js"></script>
	<!-- AdMob-->
	<script type="text/javascript" src="../../../js/admob.js"></script>
	<!-- cordova js -->
	<script src="../../../cordova.js"></script>
</head>
<body>

<div data-role="page" id="position" data-theme="a">

	<div data-role="header" data-position="fixed">
		<a data-role="button" data-rel="back" data-ajax="false" class="ui-nodisc-icon transparentButton" data-icon="carat-l" data-iconpos="notext" data-theme="a">Кнопка назад</a>
		<h1>Описание</h1>
		<a href="../../../index.html" data-ajax="false" class="ui-nodisc-icon transparentButton" data-role="button" data-icon="home" data-iconpos="notext" data-shadow="false" data-transition="none" data-theme="a">На главную</a>
	</div>

	<div data-role="main" class="ui-content">

		<h3>TLS</h3>

		<p><strong>TLS</strong> transport layer security — Протокол защиты транспортного уровня), как и его предшественник SSL (англ. secure sockets layer — слой защищённых сокетов), — криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети Интернет. TLS и SSL используют асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и коды аутентичности сообщений для сохранения целостности сообщений.</p>

		<p>Данный протокол широко используется в приложениях, работающих с сетью Интернет, таких как веб-браузеры, работа с электронной почтой, обмен мгновенными сообщениями и IP-телефония (VoIP).</p>

		<p>TLS-протокол основан на спецификации протокола SSL версии 3.0, разработанной компанией Netscape Communications. Сейчас развитием стандарта TLS занимается IETF. Последнее обновление протокола было в RFC 5246 (август 2008) и RFC 6176 (март 2011).</p>

		<hr><h3>Описание</h3>

		<p>TLS даёт возможность клиент-серверным приложениям осуществлять связь в сети таким образом, что нельзя производить прослушивание пакетов и осуществить несанкционированный доступ.</p>

		<p>Так как большинство протоколов связи может быть использовано как с, так и без TLS (или SSL), при установке соединения необходимо явно указать серверу, хочет ли клиент устанавливать TLS. Это может быть достигнуто либо с помощью использования унифицированного номера порта, по которому соединение всегда устанавливается с использованием TLS (как, например, порт 443 для HTTPS), либо с использованием произвольного порта и специальной команды серверу со стороны клиента на переключение соединения на TLS с использованием специальных механизмов протокола (как, например, STARTTLS для протоколов электронной почты). Как только клиент и сервер договорились об использовании TLS, им необходимо установить защищённое соединение. Это делается с помощью процедуры подтверждения связи. Во время этого процесса клиент и сервер принимают соглашение относительно различных параметров, необходимых для установки безопасного соединения.</p>

		<p>Основные шаги процедуры создания защищённого сеанса связи:</p>

		<ul>
			<li>клиент подключается к серверу, поддерживающему TLS, и запрашивает защищённое соединение;</li>
			<li>клиент предоставляет список поддерживаемых алгоритмов шифрования и хеш-функций;</li>
			<li>сервер выбирает из списка, предоставленного клиентом, наиболее надёжные алгоритмы среди тех, которые поддерживаются сервером, и сообщает о своём выборе клиенту;</li>
			<li>сервер отправляет клиенту цифровой сертификат для собственной аутентификации. Обычно цифровой сертификат содержит имя сервера, имя удостоверяющего центра сертификации и открытый ключ сервера;</li>
			<li>клиент, до начала передачи данных, проверяет валидность (аутентичность) полученного серверного сертификата относительно имеющихся у клиента корневых сертификатов удостоверяющих центров (центров сертификации). Клиент также может проверить, не отозван ли серверный сертификат, связавшись с сервисом доверенного удостоверяющего центра;</li>
			<li>для шифрования сессии используется сеансовый ключ. Получение общего секретного сеансового ключа клиентом и сервером проводится по протоколу Диффи-Хеллмана. Существует исторический метод передачи сгенерированного клиентом секрета на сервер при помощи шифрования асимметричной криптосистемой RSA (используется ключ из сертификата сервера). Данный метод не рекомендован, но иногда продолжает встречаться на практике.</li>
		</ul>

		<p>На этом заканчивается процедура подтверждения связи. Между клиентом и сервером установлено безопасное соединение, данные, передаваемые по нему, шифруются и расшифровываются с использованием симметричной криптосистемы до тех пор, пока соединение не будет завершено.</p>

		<p>При возникновении проблем на некоторых из вышеуказанных шагов подтверждение связи может завершиться с ошибкой, а безопасное соединение не будет установлено.</p>

		<hr><h3>Безопасность</h3>

		<p>TLS имеет множество мер безопасности:</p>

		<ul>
			<li>Защита от понижения версии протокола к предыдущей (менее защищённой) версии или менее надёжному алгоритму шифрования;</li>
			<li>Нумерация последовательных записей приложения и использование порядкового номера в коде аутентификации сообщения (MAC);</li>
			<li>Использование ключа в идентификаторе сообщения (только владелец ключа может сгенерировать код аутентификации сообщения). Алгоритм вычисления кода аутентификации (HMAC), используемый во многих сессиях TLS, определён в RFC 2104;</li>
			<li>Сообщение, которым заканчивается подтверждение связи («Finished»), используется для подтверждения аутентичности ранее переданных сообщений и, таким образом, выбранных параметров TLS-соединения.</li>
		</ul>

		<p>Уязвимость протокола TLS 1.0, которая считалась теоретической, была продемонстрирована на конференции Ekoparty в сентябре 2011 года. Демонстрация включала в себя дешифрование cookies, использованных для аутентификации пользовател.</p>

		<p>Уязвимость в фазе возобновления соединения, обнаруженная в августе 2009 года, позволяла криптоаналитику, способному взломать https-соединение, добавлять собственные запросы в сообщения, отправленные от клиента к сервер. Так как криптоаналитик не может дешифровать переписку сервера и клиента, этот тип атаки отличается от стандартной атаки, типа человек посередине. В случае, если пользователь не обращает внимания на индикацию браузера о том, что сессия является безопасной (обычно значок замка), уязвимость может быть использована для атаки типа человек посередин. Для устранения этой уязвимости было предложено как на стороне клиента, так и на стороне сервера добавлять информацию о предыдущем соединении и осуществлять проверку при возобновлении соединения. Это было представлено в стандарте RFC 5746, а также реализовано в последних версиях OpenSS и других библиотеках.</p>

		<p>Также существуют варианты атак, основанные непосредственно на программной реализации протокола, а не на его алгоритме.</p>

		<p><strong>Процедура подтверждения связи в TLS в деталях</strong></p>

		<p>Согласно протоколу TLS, приложения обмениваются записями, инкапсулирующими (хранящими внутри себя) информацию, которая должна быть передана. Каждая из записей может быть сжата, дополнена, зашифрована или идентифицирована MAC (код аутентификации сообщения) в зависимости от текущего состояния соединения (состояния протокола). Каждая запись в TLS содержит следующие поля: Content Type (определяет тип содержимого записи), Version (поле, указывающее версию протокола TLS) и Length (поле, указывающее длину пакета).</p>

		<p>Когда соединение только устанавливается, взаимодействие идёт по протоколу TLS handshake, content type которого - 22.</p>

		<p><strong>Простое подтверждение связи в TLS</strong></p>

		<p>Далее показан простой пример установления соединения, при котором сервер (но не клиент) проходит аутентификацию по его сертификату.</p>

		<ol>
			<li>Фаза переговоров:<ul>
				<li>Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых шифронаборов (методов шифрования, англ. cipher suites), подходящих для работы с TLS;</li>
				<li>Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, сгенерированное сервером, выбранный шифронабор из списка, предоставленного клиентом;</li>
				<li>Сервер посылает сообщение Certificate, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);</li>
				<li>Если переданных сервером данных недостаточно для выработки общего симметричного секретного ключа в рамках выбранного шифронабора, сервер передаёт сообщение ServerKeyExchange, в котором передаются необходимые данные. Например, в ServerKeyExchange передаётся серверная часть обмена для протокола Диффи-Хеллмана;</li>
				<li>Сервер отсылает сообщение ServerHelloDone, идентифицирующее окончание первого раунда установления соединения;</li>
				<li>Клиент отвечает сообщением ClientKeyExchange, которое содержит клиентскую часть протокола Диффи-Хеллмана или зашифрованный открытым ключом из сертификата сервера секрет (PreMasterSecret);</li>
				<li>Клиент и сервер, используя ключ PreMasterSecret и случайно сгенерированные числа, вычисляют общий секрет. Вся остальная информация о сеансовом ключе будет получена из общего секрета;</li>
			</ul></li>
			<li>Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщение уровня записей и поэтому имеет тип 20, а не 22;<ul>
				<li>Клиент посылает сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;</li>
				<li>Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;</li>
			</ul></li>
			<li>Сервер посылает ChangeCipherSpec и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.</li>
		</ol>

		<p>С этого момента подтверждение связи считается завершённым, протокол - установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.</p>

		<p><strong>Подтверждение связи с аутентификацией клиента</strong></p>

		<p>В данном примере показана полная аутентификация клиента (в дополнение к аутентификации сервера, как в предыдущем примере) с помощью обмена сертификатами между сервером и клиентом.</p>

		<ol>
			<li>Фаза переговоров:<ul>
				<li>Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS;</li>
				<li>Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом;</li>
				<li>Сервер посылает сообщение Certificate, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);</li>
				<li>Сервер посылает сообщение CertificateRequest, которое содержит запрос сертификата клиента для взаимной проверки подлинности;</li>
				<li>Клиент посылает сообщение Certificate, которое содержит цифровой сертификат клиента;</li>
				<li>Сервер отсылает сообщение ServerHelloDone, идентифицирующее окончание подтверждения связи;</li>
				<li>Клиент отвечает сообщением ClientKeyExchange, которое содержит открытый ключ PreMasterSecret или ничего (опять же зависит от алгоритма шифрования);</li>
				<li>Клиент и сервер, используя ключ PreMasterSecret и случайно сгенерированные числа, вычисляют общий секретный ключ. Вся остальная информация о ключе будет получена из общего секретного ключа (и сгенерированных клиентом и сервером случайных значений);</li>
			</ul></li>
			<li>Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;<ul>
				<li>Клиент посылает сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;</li>
				<li>Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано.</li>
			</ul></li>
			<li>Сервер посылает ChangeCipherSpec и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.</li>
		</ol>

		<p>С этого момента подтверждение связи считается завершённым, протокол установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.</p>

		<p><strong>Возобновление TLS-соединения</strong></p>

		<p>Алгоритмы асимметричного шифрования, использующиеся при генерации сеансового ключа, обычно являются дорогими с точки зрения вычислительных мощностей. Для того чтобы избежать их повторения при возобновлении соединения, TLS создаёт специальный ярлык при подтверждении связи, использующийся для возобновления соединения. При этом при обычном подтверждении связи клиент добавляет в сообщение ClientHello идентификатор предыдущей сессии session id. Клиент связывает идентификатор session id с IP-адресом сервера и TCP-портом так, чтобы при соединении к серверу можно было использовать все параметры предыдущего соединения. Сервер сопоставляет идентификатор предыдущей сессии session id c параметрами соединения, такими как использованный алгоритм шифрования и master secret. Обе стороны должны иметь одинаковый master secret, иначе соединение не будет установлено. Это предотвращает использование session id криптоаналитиком для получения несанкционированного доступа. Случайные цифровые последовательности в сообщениях ClientHello и ServerHello позволяют гарантировать, что сгенерированный сеансовый ключ будет отличаться от сеансового ключа при предыдущем соединении. В RFC такой тип подтверждения связи называется сокращённым.</p>

		<ol>
			<li>Фаза переговоров:<ul>
				<li>Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS; Также в сообщение добавляется идентификатор предыдущего соединения session id.</li>
				<li>Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом. Если сервер узнал идентификатор сессии session id, то он добавляет в сообщение ServerHello тот же самый идентификатор session id. Это является сигналом для клиента о том, что можно использовать возобновление предыдущей сессии. Если сервер не узнал идентификатор сессии session id, то он добавляет в сообщение ServerHello другое значение вместо session id. Для клиента это означает, что использовать возобновлённое соединение нельзя. Таким образом, сервер и клиент должны иметь одинаковый master secret и случайные числа для генерации сеансового ключа;</li>
			</ul></li>
			<li>Сервер посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;<ul>
				<li>Сервер посылает зашифрованное сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;</li>
				<li>Клиент пытается расшифровать Finished сообщение сервера и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;</li>
			</ul></li>
			<li>Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ.<ul>
				<li>Клиент посылает своё зашифрованное сообщение Finished;</li>
				<li>Сервер схожим образом пытается расшифровать Finished-сообщение клиента и проверить хеш и MAC;</li>
			</ul></li>
			<li>С этого момента подтверждение связи считается завершённым, протокол - установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.</li>
		</ol>

		<p>Кроме преимуществ с точки зрения производительности, алгоритм возобновления соединения может быть использован для реализации единого входа, поскольку гарантируется, что исходная сессия, как и любая возобновлённая сессия, инициирована тем же самым клиентом (RFC 5077). Это имеет особенно важное значение для реализации FTPS протокола, который в противном случае был бы уязвим к атаке типа "человек посередине", при которой злоумышленник мог бы перехватить содержание данных при установлении повторного соединения.</p>

		<p><strong>Мандаты сессий</strong></p>

		<p>RFC 5077 расширяет TLS через использование мандатов сессий (англ. session tickets) вместо идентификаторов соединений (session id). Он определяет способ возобновления сеанса TLS, не требуя session id предыдущей сессии, состояние которой хранится на TLS-сервере.</p>

		<p>При использовании сессионных мандатов TLS-сервер хранит сеансовое состояние в мандате сеанса и посылает мандат для хранения на TLS-клиенте. Клиент возобновляет TLS-сессию, отправив мандат сеанса на сервер, а сервер возобновляет TLS-сессию в соответствии с параметрами конкретной сессии, сохранёнными в принятом мандате. Сессионный мандат шифруется, в зашифрованном виде проходит аутентификацию на сервере, и сервер проверяет обоснованность мандата прежде, чем использовать его содержимое.</p>

		<p>Одна из слабостей этого метода — для шифрования и аутентификации передаваемых сессионных мандатов всегда используется только метод AES128-CBC-SHA256, независимо от того, какие параметры TLS выбраны и используются для самого TLS-соединения. Это означает, что информация о TLS-сессии (сохраняемая в сессионном мандате) не так хорошо защищена, как в рамках самой TLS-сессии. Особую озабоченность вызывает хранение OpenSSL-ключей в контексте приложения (SSL_CTX) в течение времени жизни приложения, не допуская их повторного ввода из AES128-CBC-SHA256 сессионных мандатов без сброса OpenSSL-контекста всего приложения (что редкость, подвержено ошибкам и часто требует ручного вмешательства администратора).</p>

		<hr><h3>Алгоритмы, использующиеся в TLS</h3>

		<p>В текущей версии протокола доступны следующие алгоритмы:</p>

		<ul>
			<li>Для обмена ключами и проверки их подлинности применяются комбинации алгоритмов: RSA (асимметричный шифр), Diffie-Hellman (безопасный обмен ключами), DSA (алгоритм цифровой подписи), ECDSA;</li>
			<li>Для симметричного шифрования: RC4, IDEA, Triple DES, SEED, Camellia или AES;</li>
			<li>Для хеш-функций: MD5, SHA, SHA-256/384.</li>
		</ul>

		<p>Алгоритмы могут дополняться в зависимости от версии протокола. До версии протокола TLS 1.2 были доступны также следующие алгоритмы симметричного шифрования, но они были убраны как небезопасные: RC2, IDEA, DES.</p>

	</div>

</div>


</body>
</html>