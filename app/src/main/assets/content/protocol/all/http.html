<!DOCTYPE html>
<html>
<head>
	<!-- Charset -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title></title>
	<!-- Include meta tag to ensure proper rendering and touch zooming-->
	<meta name="view-port" content="width=device-width, initial-scale=1">
	<!-- Include jQuery Mobile stylesheets -->
	<link rel="stylesheet" href="../../../css/jquery.mobile-1.4.5.min.css" />
	<link rel="stylesheet" href="../../../css/themes/my-theme.css" />
	<link rel="stylesheet" href="../../../css/themes/jquery.mobile.icons.min.css" />
	<link rel="stylesheet" href="../../../css/my-style.css" />
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery-1.11.3.min.js"></script>
	<!-- Include the jQuery Mobile library -->
	<script type="text/javascript" src="../../../js/jquery.mobile-1.4.5.min.js"></script>
	<!-- AdMob-->
	<script type="text/javascript" src="../../../js/admob.js"></script>
	<!-- cordova js -->
	<script src="../../../cordova.js"></script>
</head>
<body>

<div data-role="page" id="position" data-theme="a">

	<div data-role="header" data-position="fixed">
		<a data-role="button" data-rel="back" data-ajax="false" class="ui-nodisc-icon transparentButton" data-icon="carat-l" data-iconpos="notext" data-theme="a">Кнопка назад</a>
		<h1>Описание</h1>
		<a href="../../../index.html" data-ajax="false" class="ui-nodisc-icon transparentButton" data-role="button" data-icon="home" data-iconpos="notext" data-shadow="false" data-transition="none" data-theme="a">На главную</a>
	</div>

	<div data-role="main" class="ui-content">

		<h3>HTTP</h3>

		<p><strong>HTTP</strong> (HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер», то есть предполагается существование:</p>

		<ul>
			<li>Потребителей (клиентов), которые инициируют соединение и посылают запрос;</li>
			<li>Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</li>
		</ul>

		<p>HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. В 2006 году — в Северной Америке доля HTTP-трафика превысила долю P2P-сетей и составила 46 %, из которых почти половина — это передача потокового видео и звука.</p>

		<p>HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV.</p>

		<p>Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения, клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.</p>

		<p>HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.</p>

		<hr><h3>Программное обеспечение</h3>

		<p>Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:</p>

		<ul>
			<li>Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);</li>
			<li>Клиенты — конечные потребители услуг сервера (отправка запроса);</li>
			<li>Прокси (посредники) для выполнения транспортных служб.</li>
		</ul>

		<hr><h3>Структура протокола</h3>

		<p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p>

		<ol>
			<li>Стартовая строка (англ. Starting line) — определяет тип сообщения;</li>
			<li>Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;</li>
			<li>Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</li>
		</ol>

		<p>Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа только тело сообщения.</p>

		<p>Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.</p>

		<p><strong>Стартовая строка</strong></p>

		<p>Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:</p>

		<ul>
			<li>GET URI — для версии протокола 0.9;</li>
			<li>Метод URI HTTP/Версия — для остальных версий.</li>
		</ul>

		<p>Здесь:</p>

		<ul>
			<li>Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод GET, список методов для версии 1.1 представлен ниже.</li>
			<li>URI определяет путь к запрашиваемому документу.</li>
			<li>Версия (англ. Version) — пара разделённых точкой цифр. Например: 1.0.</li>
		</ul>

		<p>Чтобы запросить страницу данной статьи на вики, клиент должен передать строку (задан всего один заголовок):</p>

		<center><img src="../../../images/protocol/http1.png"></center>

		<p>Стартовая строка ответа сервера имеет следующий формат: HTTP/Версия КодСостояния Пояснение, где:</p>

		<ul>
			<li>Версия — пара разделённых точкой цифр, как в запросе;</li>
			<li>Код состояния (англ. Status Code) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;</li>
			<li>Пояснение (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.</li>
		</ul>

		<p>Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:</p>

		<center><img src="../../../images/protocol/http2.png"></center>

		<p><strong>Методы</strong></p>

		<p>Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.</p>

		<p>Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.</p>

		<p>Кроме методов GET и HEAD, часто применяется метод POST.</p>

		<p><strong>OPTIONS</strong></p>

		<p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.</p>

		<p>Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.</p>

		<p>Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.</p>

		<p>Результат выполнения этого метода не кэшируется.</p>

		<p><strong>GET</strong></p>

		<p>Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.</p>

		<p>Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:</p>
		<p>GET /path/resource?param1=value1&param2=value2 HTTP/1.1</p>

		<p>Согласно стандарту HTTP, запросы типа GET считаются идемпотентными</p>

		<p>Кроме обычного метода GET, различают ещё</p>

		<ul>
			<li>Условный GET — содержит заголовки If-Modified-Since, If-Match, If-Range и подобные;</li>
			<li>Частичный GET — содержит в запросе Range.</li>
		</ul>

		<p>Порядок выполнения подобных запросов определён стандартами отдельно.</p>

		<p><strong>HEAD</strong></p>

		<p>Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.</p>

		<p>Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.</p>

		<p><strong>POST</strong></p>

		<p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер.</p>

		<p>В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).</p>

		<p>При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.</p>

		<p>Сообщение ответа сервера на выполнение метода POST не кэшируется.</p>

		<p><strong>PUT</strong></p>

		<p>Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).</p>

		<p>Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.</p>

		<p>Сообщения ответов сервера на метод PUT не кэшируются.</p>

		<p><strong>PATCH</strong></p>

		<p>Аналогично PUT, но применяется только к фрагменту ресурса.</p>

		<p><strong>DELETE</strong></p>

		<p>Удаляет указанный ресурс.</p>

		<p><strong>TRACE</strong></p>

		<p>Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</p>

		<p><strong>CONNECT</strong></p>

		<p>Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.</p>

		<p><strong>Коды состояния</strong></p>

		<p>Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. </p>

		<p>Примеры:</p>

		<center><img src="../../../images/protocol/http3.png"></center>

		<p>Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.</p>

		<p>В настоящее время выделено пять классов кодов состояния.</p>

		<ul>
			<li>1xx - Информационные;</li>
			<li>2xx - Успех;</li>
			<li>3xx - Перенаправление;</li>
			<li>4xx - Ошибка на стороне клиента;</li>
			<li>5xx - Ошибка на стороне сервера.</li>
		</ul>

		<p><strong>Заголовки</strong></p>

		<p>Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.</p>

		<p>Примеры заголовков:</p>

		<center><img src="../../../images/protocol/http4.png"></center>

		<p>Все заголовки разделяются на четыре основных группы:</p>

		<ol>
			<li>General Headers («Основные заголовки») — могут включаться в любое сообщение клиента и сервера;</li>
			<li>Request Headers («Заголовки запроса») — используются только в запросах клиента;</li>
			<li>Response Headers («Заголовки ответа») — только для ответов от сервера;</li>
			<li>Entity Headers («Заголовки сущности») — сопровождают каждую сущность сообщения.</li>
		</ol>

		<p>Именно в таком порядке рекомендуется посылать заголовки получателю.</p>

		<p>Все необходимые для функционирования HTTP заголовки описаны в основных RFC. Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «X-» для избежания конфликта имён с возможно существующими. Например, как в заголовках X-Powered-By или X-Cache. Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить Ms-Echo-Request и Ms-Echo-Reply, введённые корпорацией Microsoft для расширения WebDAV.</p>

		<p><strong>Тело сообщения</strong></p>

		<p>Тело HTTP-сообщения (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (entity-body) только в том случае, когда применяется кодирование передачи, что указывается полем заголовка Transfer-Encoding.</p>

		<center><img src="../../../images/protocol/http5.png"></center>

		<p>Поле Transfer-Encoding должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле Transfer-Encoding — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов.</p>

		Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.

		<p>Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding. Тело сообщения может быть добавлено в запрос, только когда метод запроса допускает тело объекта.</p>

		<p>Включается или не включается тело сообщения в сообщение ответа — зависит как от метода запроса, так и от кода состояния ответа. Все ответы на запрос с методом HEAD не должны включать тело сообщения, даже если присутствуют поля заголовка объекта (entity-header), заставляющие поверить в присутствие объекта. Никакие ответы с кодами состояния 1xx (Информационные), 204 (Нет содержимого, No Content), и 304 (Не модифицирован, Not Modified) не должны содержать тела сообщения. Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.</p>

		<hr><h3>Основные механизмы протокола</h3>

		<p><strong>Частичные GET</strong></p>

		<p>HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.</p>

		<p>Для получения фрагмента, клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения, сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:</p>

		<ul>
			<li>В ответе помещается заголовок Content-Range с указанием байтовых диапазонов. В соответствии с ними, фрагменты последовательно помещаются в основное тело. При этом Content-Length должен соответствовать суммарному объёму всего тела;</li>
			<li>Сервер указывает медиатип multipart/byteranges для основного содержимого и передаёт фрагменты, указывая соответствующий Content-Range для каждого элемента.</li>
		</ul>

		<p><strong>Условные GET</strong></p>

		<p>Метод GET изменяется на «условный GET», если сообщение запроса включает в себя поле заголовка If-Modified-Since. В ответ на «условный GET», тело запрашиваемого ресурса передаётся только если он изменялся после даты, указанной в заголовке If-Modified-Since. Алгоритм определения этого включает в себя следующие случаи:</p>

		<ul>
			<li>Если код статуса ответа на запрос будет отличаться от «200 OK», или дата, указанная в поле заголовка «If-Modified-Since» некорректна, ответ будет идентичен ответу на обычный запрос GET.</li>
			<li>Если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос GET.</li>
			<li>Если ресурс не изменялся после указанной даты, сервер вернет код статуса «304 Not Modified».</li>
		</ul>

		<p>Использование метода условный GET направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.</p>

		<p><strong>Согласование содержимого</strong></p>

		<p>Согласование содержимого (англ. Content Negotiation) — механизм автоматического определения необходимого ресурса при наличии нескольких разнотипных версий документа. Субъектами согласования могут быть не только ресурсы сервера, но и возвращаемые страницы с сообщениями об ошибках (403, 404 и т. п.).</p>

		<p>Различают два основных типа согласований:</p>

		<ul>
			<li>Управляемое сервером (англ. Server-Driven).</li>
			<li>Управляемое клиентом (англ. Agent-Driven).</li>
		</ul>

		<p>Одновременно могут быть использованы оба типа или каждый из них по отдельности.</p>

		<p>В основной спецификации по протоколу (RFC 2616) также выделяется так называемое прозрачное согласование (англ. Transparent Negotiation) как предпочтительный вариант комбинирования обоих типов. Последний механизм не следует путать с независимой технологией Transparent Content Negotiation (TCN, «Прозрачное согласование содержимого», которая не является частью протокола HTTP, но может использоваться с ним. У обоих существенное различие в принципе работы и самом значении слова «прозрачное» (transparent). В спецификации по HTTP под прозрачностью подразумевается, что процесс не заметен для клиента и сервера, а в технологии TCN прозрачность означает доступность полного списка вариантов ресурса для всех участников процесса доставки данных.</p>

		<p><strong>Управляемое сервером</strong></p>

		<p>При наличии нескольких версий ресурса сервер может анализировать заголовки запроса клиента, чтобы выдать, по его мнению, наиболее подходящую. В основном анализируются заголовки Accept, Accept-Charset, Accept-Encoding, Accept-Languages и User-Agent. Серверу желательно включать в ответ заголовок Vary с указанием параметров, по которым различается содержимое по запрашиваемому URI.</p>

		<p>Географическое положение клиента можно определить по удалённому IP-адресу. Это возможно за счёт того что IP-адреса, как и доменные имена, регистрируются на конкретного человека или организацию. При регистрации указывается регион, в котором будет использоваться желаемое адресное пространство. Эти данные общедоступны, и в Интернете можно найти соответствующие свободно распространяемые базы данных и готовые программные модули для работы с ними (следует ориентироваться на ключевые слова «Geo IP»).</p>

		<p>Следует помнить что такой метод способен определить местоположение максимум с точностью до города (отсюда определяется и страна). При этом информация актуальна только на момент регистрации адресного пространства. Например, если московский провайдер зарегистрирует диапазон адресов с указанием Москвы и начнёт предоставлять доступ клиентам из ближайшего Подмосковья, то его абоненты могут на некоторых сайтах наблюдать, что они из Москвы, а не из Красногорска или Дзержинского.</p>

		<p>Управляемое сервером согласование имеет несколько недостатков:</p>

		<ul>
			<li>Сервер только предполагает, какой вариант наиболее предпочтителен для конечного пользователя, но не может знать точно, что именно нужно в данный момент (например, версия на русском языке или английском).</li>
			<li>Заголовков группы Accept передаётся много, а ресурсов с несколькими вариантами — мало. Из-за этого оборудование испытывает избыточную нагрузку.</li>
			<li>Общему кэшу создаётся ограничение возможности выдавать один и тот же ответ на идентичные запросы от разных пользователей.</li>
			<li>Передача заголовков Accept также может раскрывать некоторые сведения о его предпочтениях, таких как используемые языки, браузер, кодировка.</li>
		</ul>

		<p><strong>Управляемое клиентом</strong></p>

		<p>В данном случае тип содержимого определяется только на стороне клиента. Для этого сервер возвращает в ответе с кодом состояния 300 (Multiple Choices) или 406 (Not Acceptable) список вариантов, среди которых пользователь выбирает подходящий. Управляемое клиентом согласование хорошо, когда содержимое различается по самым частым параметрам (например, по языку и кодировке) и используется публичный кэш.</p>

		<p>Основной недостаток — лишняя нагрузка, так как приходится делать дополнительный запрос, чтобы получить нужное содержимое.</p>

		<p><strong>Прозрачное согласование</strong></p>

		<p>Данное согласование полностью прозрачно для клиента и сервера. В данном случае используется общий кэш, в котором содержится список вариантов, как для управляемого клиентом согласования. Если кэш понимает все эти варианты, то он сам делает выбор, как при управляемом сервером согласовании. Это снижает нагрузки с исходного сервера и исключает дополнительный запрос со стороны клиента.</p>

		<p>В основной спецификации по протоколу HTTP механизм прозрачного согласования подробно не описан.</p>

		<p><strong>Множественное содержимое</strong></p>

		<p>Протокол HTTP поддерживает передачу нескольких сущностей в пределах одного сообщения. Причём сущности могут передаваться не только в виде одноуровневой последовательности, но в виде иерархии с вложением элементов друг в друга. Для обозначения множественного содержимого используются медиатипы multipart/*. Работа с такими типами осуществляется по общим правилам, описанным в RFC 2046 (если иное не определено конкретным медиатипом). Если получателю не известно как работать с типом, то он обрабатывает его так же, как multipart/mixed.</p>

		<p>Параметр boundary означает разделитель между различными типами передаваемых сообщений. Например передаваемый из формы параметр DestAddress передаёт значение адреса e-mail, а следующий за ним элемент AttachedFile1 отправляет двоичное содержимое изображения формата .jpg</p>

		<p>Со стороны сервера сообщения со множественным содержимым могут посылаться в ответ на частичные GET при запросе нескольких фрагментов ресурса. В этом случае используется медиатип multipart/byteranges.</p>

		<p>Со стороны клиента при отправке HTML-формы чаще всего пользуются методом POST. Типичный пример: страницы отправки электронных писем со вложенными файлами. При отправке такого письма браузер формирует сообщение типа multipart/form-data, интегрируя в него как отдельные части, введённые пользователем, тему письма, адрес получателя, сам текст и вложенные файлы:</p>

		<center><img src="../../../images/protocol/http6.png"></center>

		<p>В примере в заголовках Content-Disposition параметр name соответствует атрибуту name в HTML-тегах &lt;INPUT&gt; и &lt;TEXTAREA&gt;. Параметр filename равен исходному имени файла на компьютере пользователя. Более подробная информация о формировании HTML-форм и вложении файлов в RFC 1867.</p>

		<hr><h3>Особенности протокола</h3>

		<p>Большинство протоколов предусматривают установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.</p>

		<p>При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющую клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может порождать ответы разных типов — в простейшем случае картинки в разных форматах).</p>

		<p>Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в HTML были введены формы.</p>

		<p>Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.</p>

	</div>

</div>


</body>
</html>